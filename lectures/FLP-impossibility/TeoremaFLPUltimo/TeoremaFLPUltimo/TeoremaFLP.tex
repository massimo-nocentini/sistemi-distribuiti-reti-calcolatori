\documentclass{article}
\usepackage[utf8x]{inputenc} % codifica scrittura
\usepackage[nochapters]{classicthesis} % nochapters
\usepackage[italian]{babel}
%\usepackage{inputenc}
\usepackage[T1]{fontenc} 
\usepackage[square,numbers]{natbib} 
\usepackage{amsmath, amsthm,tikz}
\usetikzlibrary{snakes}
\newtheorem{definizione}{Definizione}  
\newtheorem{lemma}{Lemma}
\newtheorem{teorema}{Teorema}  
\newtheorem{proprieta}{Proprietà}  
\begin{document}

\title{\rmfamily\normalfont\spacedallcaps{Risultato FLP}}
\author{\spacedlowsmallcaps{Chiara Pierucci}\\
	\spacedlowsmallcaps{Massimo Nocentini}\\
	\spacedlowsmallcaps{Valentino Bruni}}
\date{} % no date

\maketitle


\begin{abstract}
  In questo lavoro ci proponiamo di studiare il risultato di
  impossilit\`a del consenso in un sistema totalmente asincrono,
  dimostrato da Fischer, Lynch e Paterson nel 1985.

  Nella nostra esposizione intendiamo riportare i principali risultati
  raggiunti dagli autori, integrando alcuni dettagli con brevi
  interventi che abbiamo sviluppato durante lo studio.

  Questo nostro elaborato \`e diviso in due macro sezioni: la prima ha
  un taglio pi\`u teorico e tratta la prova d'impossibilit\`a; la
  seconda, invece, ha un taglio pi\`u implementativo e propone uno
  schema per risolvere il problema del consenso, aggiungendo alcune
  ipotesi.
\end{abstract}
       
\tableofcontents

\section{Introduzione}
\label{sec:intro}
Prima di mostrare il risultato principale, cerchiamo di descrivere
l'ambiente in cui andiamo a lavorare, identificando i concetti
fondamentali che saranno oggetto di discussione.\\\\
Immaginiamo che un insieme finito di processori debba collaborare con
lo scopo di raggiungere un decisione comune. Per raggiungere questo
obiettivo hanno la possibilit\`a di scambiarsi un numero finito di
messaggi ed eseguire una computazione locale (di cui non ci interessa
limitare la complessit\`a). Lo scambio di messaggi segue uno schema
\emph{asincrono} di cui riportiamo, per chiarezza, le propriet\`a:
\begin{description}
\item[consegna] se un messaggio $m$ \`e stato inviato ad un processore
  $p$, prima o poi $p$ ricever\`a $m$ una e una sola volta;
\item[ritardo] un processore $p$ non pu\`o fare assunzioni sugli
  istanti di tempo in cui ricever\`a i messaggi a lui destinati;
\item[ordine] i messaggi destinati ad un processore $p$ possono non
  essere consegnati nell'ordine in cui sono stati inviati;
\end{description}

Nei sistemi che tratteremo si contempla la possibilit\`a che alcuni
processori possano subire un guasto di natura ``stop'', cessando di
scambiare messaggi e eseguire computazione locale, pertanto escludiamo
tutti i guasti di tipo bizantino.

L'idea alla base del risultato FLP \`e quella che, nonostante avvenga
un \emph{solo} guasto, non \`e possibile per i processori raggiungere
una decisione univoca. Possiamo dare una spiegazione intuitiva dicendo
che un processore $p$ non \`e in grado di discriminare un processore
guasto da un processore che semplicemente ha bisogno di molto tempo
per eseguire la propria computazione. Di conseguenza nessun processore
pu\`o escludere altri per prendere la sua decisione. 

\section{Risultato di impossibilit\`a FLP}

Le idee introdotte nei paragrafi precedenti possono essere
formalizzate con le seguenti definizioni, nelle quali siamo
volutamente concisi e le abbiamo scritte immaginando i processori come
semplici macchine di Turing:

\begin{definizione}[Protocollo di consenso]
  Un protocollo di consenso $P$ è un sistema asincrono composto da $n$
  processori, con $n\geq2$. Ogni processore $P$ possiede un registro
  di input binario $x_p$, un registro di output $y_p$ con valori in
  $\{b,0,1\}$ e una memoria interna che si suppone infinita.
\end{definizione}

\begin{definizione}[Stato interno di un processore]
  Lo stato interno di un processore è costituito dal valore dei
  registri di input e di output e dal contenuto della memoria.  Diremo
  che un processore $p$ si trova in uno stato di decisione se $y_p \in
  \lbrace 0,1 \rbrace$. 
\end{definizione}

Sottolineiamo che una volta raggiunto uno stato di decisione, un
processore $p$ non pu\`o pi\`u modificare il valore $y_p$.

\subsection{Astrazione del sistema asincrono}

In questa sezione sviluppiamo le astrazioni necessarie per catturare i
concetti e le propriet\`a del sistema asincrono che abbiamo descritto
in Sezione \ref{sec:intro}.

\begin{definizione}[Messaggio]
  Un messaggio è una coppia $(p,m)$ dove $p$ è il processo
  destinatario e $m$ è il contenuto da recapitare a $p$.
\end{definizione}

Per formalizzare il ritardo arbitrario e il non ordine di ricezione
dei messaggi, introduciamo l'entit\`a \emph{message buffer}, unico
meccanismo per lo scambio di messaggi. Il lettore deve dunque
immaginare che due processi non possono comunicare ``direttamente'',
ma devono depositare i loro messaggi usando questa entit\`a.

\begin{definizione}[Message buffer]
  Un \emph{message buffer} \`e una struttura dati simile ad un
  insieme, contenente messaggi inviati ma non ancora ricevuti dai vari
  processori. Per garantire lo scambio di messaggi, un message buffer
  supporta le seguenti operazioni:
\begin{itemize}
\item \texttt{send$(p,m)$}: il messaggio $(p,m)$ è inserito nel buffer
  ed è pronto per essere recapitato;
\item \texttt{receive$(p)$}: un messaggio viene recapitato a $p$. Più
  precisamente, il message buffer decide se estrarre un messaggio
  $(p,m)$ e recapitare $m$ oppure inviare un messaggio speciale
  $\perp$ lasciando inalterato il contenuto del buffer.
\end{itemize}
\end{definizione}
La precedente definizione mette in risalto il non determinismo dello
scambio di messaggi. Infatti, se un processo $p$ invoca la primitiva
\texttt{receive(p)}, il message buffer può arbitrariamente decidere di
inviare al processo $p$ il contenuto speciale $\perp$ anche in
presenza di un messaggio $m$. Per formalizzare la propriet\`a di
consegna di ogni messaggio ad un processo $p$, il message buffer, a
seguito di infinite \texttt{receive(p)}, può rispondere $\perp$ un
numero \emph{finito} di volte, non conosciuto a priori. Quindi, se un
processore $p$ invoca la primitiva \texttt{receive(p)} infinite volte,
ha la garanzia di riceve, prima o poi, \emph{tutti} i messaggi a lui
destinati. Alla luce di queste osservazioni, diremo che un processore
$p$ si dice guasto se può effettuare solo un numero finito di
\texttt{receive(p)}.

\subsection{Grafo di esecuzione}

In questa sezione formalizziamo il concetto di esecuzione del
protocollo, costruendo un grafo che ha per vertici le
\emph{configurazioni} e per archi gli \emph{step}. Diamo le
definizioni di quest'ultimi due concetti:

\begin{definizione}[Configurazione]
  Una \emph{configurazione} \`e costituita dall'insieme degli stati
  interni dei processori e dal contenuto del message buffer. Una
  configurazione si dice iniziale quando il message buffer è vuoto e
  lo stato interno di ogni processore $p$ è tale che $y_p = b$.
\end{definizione}

\begin{definizione}[Step]
  Uno \emph{step} associa due configurazioni $C_1, C_2$ rispetto ad un
  processore $p$ e a un messaggio $m \in M\cup\{\perp\}$, e
  scriveremo $C_1 \xrightarrow{(p,m)} C_2$, se e solo
  se $p$:
  \begin{enumerate}
  \item esegue \texttt{receive($p$)} ottenendo $m$;
  \item in base al suo stato interno computa un nuovo stato e invia un
    insieme finito di messaggi agli altri processori, modificando
    quindi il contenuto del message buffer.
  \end{enumerate} 
  Il comportamento deterministico del processore è completamente
  determinato dalla coppia $e=(p,m)$ chiamata evento, con lieve abuso
  di notazione. Se $C_1 \xrightarrow{e} C_2$ allora indichiamo con
  $e(C_1)=C_2$ la configurazione raggiunta applicando l'evento $e$ a
  $C_1$.
\end{definizione}

Un cammino del grafo rappresenta una possibile esecuzione del
protocollo, pertanto definiamo il concetto di \emph{run}:

\begin{definizione}[Run]
  Un \emph{run} è una sequenza $\sigma$, finita o infinita, di eventi
  che può essere applicata ad una configurazione $C$; se $\sigma$ è
  finita indichiamo con $\sigma(C)$ la configurazione raggiunta
  eseguendo $\sigma$ a partire da $C$. Una configurazione si dice
  \emph{accessibile} se \`e raggiungibile da una configurazione
  iniziale.
\end{definizione}

Nel seguente lemma riportiamo un risultato generale che ci sar\`a
utile nelle prove successive. L'idea alla base \`e quella di
considerare due run in cui insiemi disgiunti di processi ricevono
messaggi: se applichiamo i due run ad una stessa configurazione,
arriveremo in due configurazioni distinte, in cui i messaggi destinati
ai processi non coinvolti saranno disponibili e quindi possiamo
scambiare l'applicazione dei run, raggiungendo la stessa
configurazione (Figura \ref{fig:concatenazioneSchedule}).

\begin{lemma}
  Sia $C$ una configurazione e siano $\sigma_1$, $\sigma_2$ due run
  che operano su insiemi di processori disgiunti. Allora
  $\sigma_2(\sigma_1(C))=\sigma_1(\sigma_2(C))$.
\end{lemma}

\begin{proof}
  Siano $P_1$ e $P_2$ gli insiemi dei processori coinvolti
  rispettivamente in $\sigma_1$ e $\sigma_2$. Sia $C_1=\sigma_1(C)$ e
  sia $C_2=\sigma_2(C)$. In $C_1$ solo i processori in $P_1$ avranno
  ricevuto messaggi e modificato il loro stato, così come succede per
  i processori in $P_2$. Dal punto di vista dei processori in $P_1$ le
  configurazioni $C$ e $C_2$ sono equivalenti e, per quelli in $P_2$
  sono equivalenti le configurazioni $C$ e $C_1$. Applicando
  $\sigma_2$ a $C_1$ si modifica lo stato interno dei soli processori
  in $P_2$ e, analogamente, applicando $\sigma_1$ a $C_2$ si altera lo
  stato interno dei soli processori in $P_1$. Dunque, dato il
  comportamento deterministico dei processori, vale
  $\sigma_2(C_1)=\sigma_1(C_2)=C'$.
\end{proof}

\begin{figure}[!h]
  \centering \input{img/concatenazioneSchedule.tex}\caption{Run
    disgiunti concatenati}\label{fig:concatenazioneSchedule}
\end{figure}

\subsection{Consenso e correttezza totale del protocollo}

Questa sezione prepara il lettore alla prova del teorema FLP,
precisando che cosa significa raggiungere il consenso, in ambiente
asincrono, per un insieme di processori. Nonostante nella realt\`a sia
richiesto che tutti i processori non guasti decidano lo stesso valore,
nel nostro studio ci siamo focalizzati sulla versione ``debole'' del
problema: ci interessa dimostrare che pur considerando un solo
processo guasto, \emph{nessun} processore \`e in grado di raggiungere
una decisione.

\begin{definizione}[Valore di decisione di una configurazione]
  Una configurazione $C$ ha valore di decisione $v \in \{0,1\}$ se
  almeno un processore $p$ si trova in uno stato di decisione con
  $y_p=v$.
\end{definizione}

\begin{definizione}[Protocollo parzialmente corretto]
  Un protocollo di consenso $P$ si dice \emph{parzialmente corretto}
  se:
\begin{itemize}
\item nessuna configurazione accessibile ha più di un valore di
  decisione;
\item esiste una configurazione accessibile con valore di decisione
  $0$ e una con valore di decisione $1$.
\end{itemize}  
\end{definizione}

\begin{figure}[!h]
  \centering \input{img/parzialmenteCorretto.tex}\caption{Run
    parzialmente corretto}\label{fig:parzialmenteCorretto}
\end{figure}

\begin{definizione}[Run ammissibile]
  Un run $\sigma$ si dice \emph{ammissibile} se 
  \begin{itemize}
  \item per ogni configurazione $C$ raggiunta attraverso un evento
    $e\in \sigma$, $C$ contiene al più un processore guasto;
  \item esiste una configurazione $C$ raggiunta attraverso un evento
    $e\in \sigma$ tale che per ogni processore $p$ non guasto, tutti i
    messaggi contenuti nel message buffer in $C$ destinati a $p$
    verranno prima o poi recapitati.
  \end{itemize}
\end{definizione}

\begin{definizione}[Run decisionale]
  Un run $\sigma$ si dice \emph{decisionale} se esiste una
  configurazione $C$ raggiunta attraverso un evento $e\in \sigma$ tale
  che almeno un processo raggiunge uno stato di decisione.
\end{definizione}

\begin{definizione}[Protocollo totalmente corretto a meno di un guasto]
  Un protocollo di consenso $P$ si dice \emph{totalmente corretto},
  nonostante la presenza di un guasto, se:
\begin{itemize}
\item  $P$ è parzialmente corretto;
\item per ogni run $\sigma$: $\sigma$ \`e ammissibile $\rightarrow
  \sigma$ \`e decisionale.
\end{itemize}
\end{definizione}

\begin{teorema}
Non esistono protocolli di consenso totalmente corretti a meno di un guasto.
\end{teorema}

\begin{proof}
L'idea alla base della prova è quella di procedere per assurdo assumendo che esista un protocollo $P$ totalmente corretto a meno di un guasto. Proveremo dei risultati intermedi, assumendo che esista il protocollo $P$, per arrivare ad una contraddizione. La dimostrazione si articola in due fasi:
\begin{enumerate}
\item dimostrare l'esistenza di configurazioni iniziali da cui, usando due run distinte, è possibile raggiungere due configurazioni con valore di decisione distinto;
\item dimostrare l'esistenza di un run infinito tale che ogni configurazione attraversata non ha valore di decisione.
\end{enumerate}
La prima fase ci assicura che esistono delle esecuzioni in cui la decisione non è predeterminata mentre, nella seconda, abbiamo la necessità di usare un run infinito in quanto ogni processo non guasto deve essere in grado di eseguire un numero infinito di volte la primitiva \texttt{receive} per poter ricevere tutti i messaggi.\\
Formalizziamo lo scopo della prima fase nel seguente modo: 
\begin{itemize}
\item una configurazione $C$ si dice bivalente se l'insieme dei valori di decisione delle configurazioni raggiungibili da $C$ è $\{0,1\}$;
\item una configurazione $C$ si dice 1-valente se l'insieme dei valori di decisione delle configurazioni raggiungibili da $C$ è $\{1\}$;
\item una configurazione $C$ si dice 0-valente se l'insieme dei valori di decisione delle configurazioni raggiungibili da $C$ è $\{0\}$.
\end{itemize}

Osserviamo che l'insieme dei valori di decisione non può essere vuoto in quanto il protocollo $P$ è supposto totalmente corretto e dunque contiene al suo interno solo run decisionali, ovvero ogni run conterrà una configurazione con un valore di decisione.

\begin{lemma}
Il protocollo $P$ possiede una configurazione iniziale bivalente.
\end{lemma}

\begin{proof}
Per assurdo, assumiamo che non esista alcuna configurazione iniziale bivalente. Dunque, tutte le configurazioni di $P$ devono essere o 1-valenti o 0-valenti. Costruiamo un ordinamento sulle configurazioni iniziali di $P$ usando il seguente criterio: una configurazione $C_1$ precede $C_2$ se e solo se i valori iniziali dei processori sono gli stessi a meno di esattamente un processore. Usando tale ordinamento, dimostriamo che esistono due configurazioni consecutive tali che una risulta 0-valente e l'altra è 1-valente. Per mostrare ciò supponiamo che, senza perdita di generalità, tutte le configurazioni ordinate siano 0-valenti. Tuttavia tale assunzione non rispetta la richiesta di parziale correttezza del protocollo $P$, in particolare deve esistere una configurazione decisionale con valore $1$. Quindi, scegliamo una configurazione iniziale $C_1$ che ne raggiunga una con valore decisionale 1 e consideriamo una configurazione $C_0$ a lei consecutiva (quest'ultima esiste sempre per come abbiamo definito l'ordinamento). Dato che $C_0$ e $C_1$ sono consecutive, esse differiscono per un solo valore iniziale in corrispondenza di un processore $p$. Costruiamo $\sigma$ un run decisionale (non possiamo fare altrimenti poichè $P$ è supposto totalmente corretto) in cui il processore $p$ non è coinvolto ($p$ non riceve messaggi). Applicando $\sigma$ a $C_0$ e a $C_1$ si raggiungono due configurazioni in cui lo stato di ogni processo $p'\neq p$ è uguale in entrambe; l'unica differenza è il valore iniziale relativo a $p$. Ma dato che $\sigma$ è un run decisionale solo due valori potranno essere decisi: se sarà deciso $0$ allora $C_1$ è bivalente, se verrà deciso $1$ allora $C_0$ è bivalente. In entrambi i casi abbiamo raggiunto una contraddizione in quanto sia $C_0$ che $C_1$ erano supposte non bivalenti.

% Figura matrice collezione di configurazioni
% commento relativo al fatto che sigma e dunque il contenuto del message buffer è fissato e deciso da noi. 

 \end{proof}
 
 \begin{lemma}
Sia $C$ una configurazione bivalente del protocollo $P$, e sia $e=(p,m)$ un evento applicabile a $C$. Sia $\mathcal{C}$ l'insieme delle configurazioni raggiungibili da $C$ senza applicare l'evento $e$, e sia $\mathcal{D}$ l'insieme di tutte le configurazioni raggiungibili applicando $e$ ad ogni configurazione presente in $\mathcal{C}$. Allora $\mathcal{D}$ contiene una configurazione bivalente. 
\end{lemma}
Osserviamo che il processo $p$ può ricevere il messaggio in $C$ e dunque, per definizione di $\mathcal{C}$, sarà possibile, per $p$, ricevere $m$ anche in ogni configurazione in $\mathcal{C}$.
\begin{proof}
Per assurdo assumiamo che $\mathcal{D}$ non contenga alcuna configurazione bivalente, dunque ogni configurazione di $\mathcal{D}$ è o 0-valente o 1-valente (tale considerazione deriva dalla assunzione di totale correttezza del protocollo $P$). Siano $E_0$ ed $E_1$ le configurazioni rispettivamente 0-valente e 1-valente raggiungibili da $C$ e analizziamo i seguenti due casi. Senza perdita di generalità, ci focalizzeremo sullo studio di $E_0$ da momento che lo stesso ragionamento si può ripetere per $E_1$.
\begin{itemize}
\item $E_0 \in \mathcal{C}$ e dunque è possibile applicare l'evento $e$ alla configurazione $E_0$ ottenendo una configurazione $F_0 \in \mathcal{D}$. Infatti, applicare $e$ equivale a far ricevere il messaggio $m$ al processore $p$ e a raggiungere la configurazione $F_0 \in \mathcal{D}$. Per l'ipotesi di assurdo su $\mathcal{D}$, $F_0$ deve essere monovalente: non può essere 1-valente in quanto contraddirebbe la decisione di $E_0$ e quindi anch'essa risulta 0-valente;
\item  $E_0 \not \in \mathcal{C}$, dunque deve esistere una configurazione raggiungibile applicando $e$ e ottenendo quindi una nuova configurazione $F_0' \in \mathcal{D}$ dalla quale è possibile arrivare a $E_0$. Dato che $F_0' \in \mathcal{D}$ quest'ultima risulta monovalente ma dato che dovrà raggiungere $E_0$ che è 0-valente deve rispettarne la decisione per non violare la validità del protocollo.    
\end{itemize}
Notiamo quindi che a prescindere dai due casi, $\mathcal{D}$ conterrà una configurazione 0-valente. Tuttavia, ripetendo un ragionamento analogo per la configurazione $E_1$ si ottiene che $\mathcal{D}$ deve contenere anche una configurazione 1-valente, contraddicendo l'ipotesi della mono valenza di $\mathcal{D}$. \\
Diciamo che due configurazioni risultano vicine se una è raggiungibile dall'altra con l'applicazione di esattamente uno step, ovvero permettendo ad un processo $p$ di ricevere un messaggio $m$. Mostriamo che date due configurazioni vicine $C_{\alpha}, C_{\beta} \in \mathcal{C}$ è possibile applicare l'evento $e$ arrivando in due configurazioni da cui si decideranno valori opposti. Diamo una breve dimostrazione di questo risultato. \\
\\
Ripercorrendo i passi svolti per mostrare la presenza di sole configurazioni monovalenti in $\mathcal{D}$, possiamo assumere l'esistenza di due run ammissibili in cui compare in uno, una configurazione 0-valente e, nell'altro, una 1-valente. Supponiamo, per assurdo, che ogni coppia di configurazioni vicine debba raggiungere prima o poi lo stesso valore di decisione e osserviamo che, per derivare una contraddizione, tutte le configurazioni visitate da un run non dovrebbero essere vicine a tutte le configurazioni visitate dall'altro. Tuttavia, data l'ammissibilità dei due run, esisterà sempre almeno un processo che potrà ricevere un qualche messaggio $m$ (eventualmente il simbolo speciale) e quindi riusciremo sempre a rendere vicine due configurazioni di due diversi run, contraddicendo l'ipotesi iniziale. \\ 

%FIGURA INDUZIONE

Tale risultato ci assicura che esiste una coppia di configurazioni vicine $C_{\alpha}, C_{\beta} \in \mathcal{C}$ dalle quali, applicando l'evento $e'=(p',m')$, risulta possibile raggiungere due configurazioni $d_0$ e $d_1 \in \mathcal{D}$ con valori di decisione discordi. Analizziamo quindi i seguenti due casi:
\begin{itemize}
\item supponiamo che $p \neq p'$. Allora, dal momento che $C_{\alpha}, C_{\beta} \in \mathcal{C}$, applicando a loro l'evento $e$ si raggiungeranno rispettivamente le configurazioni $d_0$ e $d_1 \in \mathcal{D}$. Poichè $p\neq p'$ possiamo applicare l'evento $e'$ a $d_0$ raggiungendo, per il Lemma 1, $d_1$ ovvero si riesce a passare da una configurazione 0-valente ad una 1-valente, violando la correttezza del protocollo;
\item supponiamo che $p=p'$. Allora esiste $\sigma$, un run decisionale, che non coinvolge $p$ e sia $A=\sigma(C_{\alpha})$. Tale run risulta applicabile, per il Lemma 1 anche alle configurazioni $d_0$ e $d_1$ producendo rispettivamente $E_0$ e $E_1$ che, per la correttezza del protocollo, devono mantenere lo stesso valore di decisione di $d_0$ e di $d_1$. In $A$, $p$ è ancora in grado di ricevere messaggi. In particolare, si possono verificare l' evento $e$ e la concatenazione di eventi $e'e$. Risulta: $e(A)=E_0$ e $e(e'(A))=E_1$, quindi $A$ è bivalente, contraddicendo l'ipotesi che $\sigma$ sia un run decisionale.        
\end{itemize} 
\end{proof}
Abbiamo quindi tutti gli elementi per terminare la dimostrazione iniziale, mostrando come si riesca a costruire un run ammissibile ma non decisionale, ovvero una sequenza di passi che attraversa infinite configurazioni solo bivalenti. \\
Grazie al Lemma 2 sappiamo che esiste una configurazione iniziale bivalente. Chiamiamo tale configurazione $C_i$. Costruiamo il run decisionale come segue: una sequenza di eventi dove un processore riceve solo il simbolo speciale, seguita da un evento in cui viene ricevuto il messaggio.  Per il Lemma 3, tale messaggio ci assicura di raggiungere una nuova configurazione ancora bivalente che ci permette di ripetere il ragionamento fatto considerando come soggetto un nuovo processore non necessariamente diverso. La sequenza di passi così costruita è infinita in quanto almeno un processore, non essendo guasto, riuscirà sempre a ricevere messaggi, permette al massimo un guasto e ogni configurazione che vi appare risulta bivalente. Si è quindi creato un run ammissibile che tuttavia non risulta decisionale.    
\end{proof}

\section{Protocollo di consenso in presenza di processori inizialmente guasti}

Il protocollo che ci accingiamo a presentare si occupa di risolvere il problema del consenso supponendo di avere inizialmente la maggioranza dei processori non guasti e nessun guasto durante l'esecuzione del protocollo. Assumiamo che i processori non sappiano in anticipo quali di loro sono guasti ma di lavorare in un sistema non uniforme dove il numero $n$ dei processori presenti è noto. Il protocollo si articola in fasi.
\subsection{Prima fase}
In primo luogo ogni processore effettua un broadcast di un messaggio contenente la propria \textsc{id} e attende di ricevere le \textsc{id} degli altri processori. I processori funzionanti sono almeno $L=\lceil\dfrac{n+1}{2}\rceil$, ogni processore resta in attesa di esattamente $L-1$ messaggi. 
Ricevuti tali messaggi, ogni processore costruisce un grafo $G=(V,E)$ in cui $V$ contiene tutti gli $n$ processori mentre $E$ contiene l'arco $(i,j)$ se $j$ riceve il messaggio da $i$.  

Illustriamo con un esempio questa prima fase. Consideriamo $n=8$ con $2$ processori guasti e rappresentiamo in Figura (REF) i punti di vista di $k,r$ e $j$. In particolare $k$ riceve messaggi da $\alpha, \beta, \gamma$ ed $r$, $r$ riceve messaggi da $\alpha, \beta, \gamma$ e $j$, infine $j$ riceve messaggi da $\alpha, \beta, \gamma$ ed $r$.

\subsection{Seconda fase}
Ogni processore $p$ effettua un broadcast diffondendo il proprio valore iniziale e l'insieme dei processori da cui ha ottenuto l'\textsc{id} alle fase precedente; chiamiamo questi processori $\texttt{ancestors}(p)$. L'effetto del broadcast è riceve informazioni sia dagli $L-1$ processori già adiacenti ma anche dai restanti processori funzionanti; ogni processore aggiunge queste nuove informazioni al proprio grafo $G$.

Nel nostro esempio $k$ si aspetta di ricevere messaggi da $\alpha, \beta, \gamma$ ed $r$ ma, per effetto del broadcast, riceverà un messaggio anche da $j$. La sua conoscenza dopo aver collezionato questi messaggi comprende $\texttt{ancestors}(\alpha)\cup\texttt{ancestors}(\beta)\cup\texttt{ancestors}(\gamma)\cup\texttt{ancestors}(r)\cup\texttt{ancestors}(j)$.

\subsection{Terza fase}
Prima di descrivere la terza fase diamo un suggerimento su come immaginarsi questo procedimento. Disegniamo per ogni processore il suo grafo usando colori diversi per rappresentare gli archi incidenti ai nodi scelti nella prima fase più quelli ricevuti per broadcast nella seconda. Se adesso astraiamo dai diversi colori usati per disegnare un nuovo grafo otterremo lo stesso risultato per ogni processore: ogni processore ha quindi la stessa conoscenza degli altri.

Dato che tutti i processori hanno la stessa visione è possibile chiudere transitivamente il grafo costruendo $G^+$; con questa operazione si aggiungono eventuali self-loop e si trasformano i cammini presenti in archi diretti.

\subsection{Quarta fase}
Per arrivare al consenso è necessario che $L$ processori decidano in modo concorde; per raggiungere questo obiettivo usiamo il fatto che hanno la stessa conoscenza per costruire una clique iniziale. 
\begin{definizione}Considerando la chiusura transitiva $G^+$, un processore $p$ appartiene a una clique iniziale se e solo se i predecessori di $p$ hanno $p$ stesso come predecessore ovvero se $\forall q\in\mbox{predecessore}(p)\rightarrow p\in\mbox{predecessore}(q)$.\end{definizione}
I processori analizzano i propri predecessori e determinano quali di loro possono appartenere ad una clique iniziale. Dimostriamo alcune proprietà delle clique così ottenute.

\begin{teorema}[Estensione]Ogni clique iniziale ha almeno $L$ processori.\end{teorema}
\begin{proof}
Assumiamo per assurdo che esista una clique iniziale $IC$ tale che $|IC|\leq L-1$.
Consideriamo lo stage 1 del protocollo dove ogni processo non guasto riceve esattamente $L-1$ messaggi. Sia $c\in IC$, quindi non essendo guasto avrà ricevuto anche lui gli $L-1$ messaggi avendo $L-1$ \texttt{ancestor}. Dato che $c \in IC$, esso risulta antenato di tutti gli $L-1$ processori da cui ha ricevuto il messaggio. Ma, essendoci al massimo $L-1$ nodi nella clique, $c$ deve essere uno dei processori da cui ha ricevuto il messaggio. Ma questo è impossibile poichè nello stage 1 nessun processore invia messaggi a se stesso.
\end{proof}

\begin{teorema}[Esistenza]$G^+$ contiene almeno una clique iniziale.\end{teorema}
\begin{proof}
Sia $G^+$ la chiusura transitiva di $G$. In quanto tale $G^+$ contiene soltanto archi diretti: se infatti due processori $\alpha$ e $\beta$ sono connessi in $G$ tramite un arco allora anche in $G^+$ sono connessi con un arco, se $\alpha$ e $\beta$ sono connessi in $G$ tramite un cammino, in $G^+$ lo sono tramite un arco. Per definizione $p\in IC\leftrightarrow\forall q: q\in\texttt{ancestors}(p)\rightarrow p\in\texttt{ancestors}(q)$. Supponiamo, per assurdo che $\forall p: p\not\in IC$ dalla definizione segue che $p\not\in IC\leftrightarrow\exists q: q\in\texttt{ancestors}(p)\wedge p\not\in\texttt{ancestors}(q)$.\\
Scegliamo arbitrariamente un processo $p$ e sia $q$ il suo \texttt{ancestor}; poichè la clique è vuota $p$ non può essere \texttt{ancestor} di $q$. Lo stesso argomento si applica anche a $q$, in altre parole esisterà un processo $r$\texttt{ancestor} di $q$ che non ha $q$ come \texttt{ancestor}. \'E utile osservare che $r$ non può essere proprio $p$, altrimenti $p$ sarebbe \texttt{ancestor} di $q$, caso escluso precedentemente. Possiamo continuare a scegliere in modo arbitrario al più $n$ processi ma, arrivati all'ultimo dovremmo scegliere un \texttt{ancestor} tra uno dei processi precedentemente considerati, creando un ciclo, condizione necessaria per introdurre un nodo nella clique. 
\end{proof}

\begin{teorema}[Unicità]$G^+$ contiene non più di una clique iniziale.\end{teorema}
\begin{proof}
Assumiamo che esistano due clique iniziali $IC_1, IC_2$.
$IC_1$ e $IC_2$ hanno almeno $L$ processori. Dato che $L>\dfrac{n}{2}$, le due clique hanno almeno un processore $p$ in comune. Per definizione di clique, $p$ è raggiungibile da tutti i nodi di $IC_1$ e di $IC_2$ e, viceversa, tutti i nodi delle due clique sono raggiungibili da $p$. Per transitività, tutti i nodi di $IC_1$ possono raggiungere quelli di $ISC_2$ passando per $p$ così come tutti i nodi di $IC_2$ possono raggiungere quelli di $IC_1$ passando per $p$. In tal modo le due clique risultano fuse a formarne una unica, contraddicendo il fatto che $IC_1$ e $IC_2$ avevano solo $p$ in comune. 
\end{proof}

\begin{teorema}[Conoscenza]Ogni processore $p$, grazie a $G^+$, costruisce la stessa clique iniziale.\end{teorema}
\begin{proof}
Assumiamo per assurdo che esistano due processi $p$ e $q$ tali che $IC_p\neq IC_q$, differendo per almeno un nodo $z$. Nel seguito assumiamo, senza perdita di generalità, che $p$ inserisca $z$ nella clique mentre $q$, erroneamente, non faccia lo stesso. Studiamo dal punto di vista di $q$: poichè $q$ ha deciso che $z$ non appartiene alla clique, deve esistere un antenato $\gamma$ di quest'ultimo di cui $z$ non è a sua volta antenato. Distinguiamo due casi:
\begin{itemize}
\item se $q$ ha ricevuto un messaggio da $\gamma$ nello stage 1, allora $\gamma$ è \texttt{ancestor} di $q$ che, nello stage 2 riceverà da $\gamma$ l'informazione che $z$ è antenato di $\gamma$.
\item se $q$ non ha ricevuto alcun messaggio da $\gamma$ nello stage 1 allora riceverà un messaggio di broadcast nello stage 2, ricavando l'informazione che $z$ è antenato di $\gamma$.  
\end{itemize} 
 In entrambi i casi $q$ ottiene la conoscenza che $z$ è antenato di $\gamma$ e che vale anche il viceversa. Dunque anche $q$ avrebbe dovuto inserire $z$ nella clique, contraddicendo la sua scelta iniziale.
\end{proof}

\begin{teorema}[Correttezza]Il protocollo raggiunge il consenso se almeno $L$ processori sono non guasti e non si verificano guasti durante l'esecuzione.\end{teorema}
\begin{proof}
Data la chiusura transitiva $G^+$, ogni processo costruisce la stessa clique iniziale; la clique ha almeno $L$ processori.
Ogni processore usa regole deterministiche e condivise a partire dai valori iniziali dei processi nella clique iniziale, raggiungendo quindi lo stesso valore di decisione.
\end{proof}

\end{document}
